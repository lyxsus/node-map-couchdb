{
	"_id": "urn:applications/futurios-packages",
	"meta": {
		"shared": [
			"urn:applications/futurios-packages"
		],
		"created_by": "urn:accounts/252cd3e11e2e8c6a8de4bc6d8bc82581",
		"created_at": 1361626888949,
		"origin": "sys/apps",
		"origin_host": "temp-host",
		"updated_by": "urn:accounts/252cd3e11e2e8c6a8de4bc6d8bc82581",
		"updated_at": 1362067530995,
		"last_updated_origin": "sys/apps",
		"last_updated_origin_host": "temp-host",
		"sort_index": 1361626888949
	},
	"type": "urn:types/application",
	"design": {
		"_id": "_design/urn:fos:package",
		"views": {
			"urn:types/futurios-package": {
				"map": "function (doc) {\n    var filters = {\"all\":function (doc) {\n      return true;\n    },\n\"author\":function (doc) {\n      return doc.meta ? doc.meta.created_by : null;\n    },\n\"packages\":function (doc) {\n      return (function (value) {\n  return value;\n}) (doc [\"packages\"], doc);\n    }},\n        sorts = {\"created_at\":function (doc) {\n      return doc.meta ? doc.meta.created_at : null;\n    },\n\"sort_index\":function (doc) {\n      if (doc.meta) {\n        return doc.meta.sort_index || doc.meta.created_at;\n      }\n    },\n\"links-rating\":function (doc) {\n      if (doc.meta && doc.meta.rate) {\n        return (doc.meta.rate || 0) * Math.floor (doc.meta.created_at / (1000 * 3600));\n      }\n      return 0;\n    },\n\"packages\":function (doc) {\n      return (function (value, field, doc) {\n  return value;\n}) (doc [\"packages\"], doc);\n    }};\n\n    if (doc.type == \"urn:types/futurios-package\") {\n      var value = 1,\n          enabled = (doc.meta && doc.meta.disabled) ? 0 : 1;\n    \n      for (var filter in filters) {\n          var filterFun;\n        \n          if (typeof filters [filter] == 'function') {\n            filterFun = filters [filter];\n          } else {\n            filterFun = eval ('(' + filters [filter] + ')');\n          }\n\n        for (var sort in sorts) {\n          var sortFun;\n          \n          if (typeof sorts [sort] == 'function') {\n            sortFun = sorts [sort];\n          } else {\n            sortFun = eval ('(' + sorts [sort] + ')')\n          }\n\n          \n          var filterValues, sortValues;\n          \n          try {\n            filterValues = filterFun (doc);\n          } catch (e) {\n            emit (['error', 'filterFun', filter, e.messsage], 0);\n          }\n          \n          try {\n            sortValues = sortFun (doc);\n          } catch (e) {\n            emit (['error', 'sortFun', filter, e.messsage], 0);\n          }\n          \n          \n\n          if (typeof filterValues == 'object') {\n            for (var i in filterValues) {\n              if (typeof sortValues == 'object') {\n                for (var j in sortValues) {\n                  if (enabled) {\n                    emit ([1, filter, filterValues [i], sort, sortValues [j]], value);\n                  }\n                  emit ([0, filter, filterValues [i], sort, sortValues [j]], value);\n                }\n              } else {\n                if (enabled) {\n                  emit ([1, filter, filterValues [i], sort, sortValues], value);\n                }\n                emit ([0, filter, filterValues [i], sort, sortValues], value);\n              }\n            }\n          } else {\n            if (typeof sortValues == 'object') {\n              for (var j in sortValues) {\n                if (enabled) {\n                  emit ([1, filter, filterValues, sort, sortValues [j]], value);\n                }\n                emit ([0, filter, filterValues, sort, sortValues [j]], value);\n              }\n            } else {\n              if (enabled) {\n                emit ([1, filter, filterValues, sort, sortValues], value);\n              }\n              emit ([0, filter, filterValues, sort, sortValues], value);\n            }\n          }\n        }\n      }\n    }\n  }",
				"reduce": "_stats"
			},
			"by-sync-source": {
				"map": "function (doc) {\n      if (doc.type != \"urn:types/futurios-package\" || !doc.meta || !doc.meta.sync) return;\n      \n      for (var i in doc.meta.sync) {\n        emit ([i, doc.meta.sync [i]]);\n      }\n    }"
			},
			"sync-sources": {
				"map": "function (doc) {\n      if (doc.type != \"urn:types/futurios-package\") return;\n      if (!doc.meta || !doc.meta.sync) return;\n      \n      for (var i in doc.meta.sync) {\n        emit (i, 1);\n      }\n    }",
				"reduce": "_sum"
			}
		},
		"fulltext": {
			"search": {
				"analyzer": "perfield:{\"title\":\"keyword\",\"default\":\"snowball:Russian\"}",
				"index": "function (doc) {\n            var getValue = function (name, field, doc) {\n              var value = doc [name];\n              \n              if (field.index) {\n                value = eval ('(' + field.index + ')') (value, field, doc);\n              }\n              \n              return value;\n            };\n          \n            var add = function (index, name, value) {\n              if (typeof value == 'boolean') {\n                value = value ? 'true' : 'false';\n              }\n              \n              if (!value) return;\n              if (typeof value != 'string') return;\n              \n              index.add (value);\n              index.add (value, {\n                field: name,\n                index: 'not_analyzed'\n              });\n            };\n          \n            if (doc.meta && (doc.meta.disabled || doc.meta.noindex)) {\n              return;\n            }\n          \n            if (doc.type != \"urn:types/futurios-package\") {\n              return;\n            }\n          \n            var index = new Document (),\n                fields = [{\"parent\":\"urn:field/string\",\"templateRole\":{\"view\":\"fos-field-string\",\"edit\":\"fos-field-string-edit\"},\"title\":\"Название\",\"placeholder\":\"введите \",\"indexable\":true,\"filterable\":false,\"sortable\":false,\"comparable\":false,\"emptyText\":\"\",\"source\":\"\",\"limit\":\"\",\"empty\":false,\"emptyAllowed\":false,\"emptyElement\":\"\",\"filter\":\"function (value) {\\n  return value;\\n}\",\"index\":\"function (value, field, doc) {\\n  if (typeof value == 'object') {\\n    var values = [];\\n    for (var i in value) {\\n      values.push (value);\\n    }\\n    return values;\\n  } else return value;\\n}\",\"sort\":\"function (value, field, doc) {\\n  return (typeof value == 'string') ? value.substring (0, 3) : \\\"\\\";\\n}\",\"validate\":\"function (value, field, attrs) {\\n  if (field.required && !value) {\\n    return 'Заполните поле';\\n  }\\n  \\n  if (field.pattern) {\\n    var regexp;\\n    \\n    try {\\n      regexp = eval (field.pattern);\\n    } catch (e) {\\n      console.error ('Failed to parse pattern', 'in', field.name, e.message, e.stack);\\n      return;\\n    }\\n    \\n    if (regexp instanceof RegExp) {\\n      if (!value.match (regexp)) {\\n        return 'Неверный формат поля';\\n      }\\n     } else {\\n       console.error ('Invalid field pattern', field.pattern, 'in', field.name);\\n     }\\n  }\\n}\",\"type\":\"urn:fos:field/string\",\"name\":\"title\",\"prefetch\":false,\"description\":\"\",\"sortableValue\":false,\"meta\":{\"override\":[\"name\",\"title\"]},\"schema\":[\"urn:fos:schema/string\"]}],\n                name, field, value;\n          \n            for (var i = 0; i < fields.length; i++) {\n              field = fields [i];\n              name = field.name;\n              value = getValue (name, field, doc);\n              \n              if (typeof value == 'object') {\n                for (var j in value) {\n                  add (index, name, value [j]);\n                }\n              } else {\n                add (index, name, value);\n              }\n            }\n            \n            for (var a in doc._attachments) {\n              index.attachment ('default', a);\n            }\n            \n            return index;\n          }"
			}
		},
		"defaultResolve": "function (urn, resolved) {\n    var options = urn.search (true),\n        filter = options.filter || 'all',\n        where = options ['where'] || true,\n        sort = options.sort || 'sort_index',\n        descending = options.descending == 'true',\n        enabled = (options.disabled != undefined) ? 0 : 1,\n        range;\n\n\n    if (typeof options.search != 'undefined') {\n        resolved.fti = true;\n        resolved.view = 'search';\n        resolved.search = options.search;\n      \n        resolved.fields = {};\n      \n        var skipFields = ['search', 'limit', 'skip', 'descending', 'sort', 'filter', 'include_docs'];\n      \n        for (var i in options) {\n          if (skipFields.indexOf (i) == -1) {\n            resolved.fields [i] = options [i];\n          }\n        }\n\n        resolved.final = true;\n\n        return resolved;\n    }\n    \n    if (typeof options ['author'] != 'undefined') {\n      filter = 'author';\n      where = options ['author'];\n    }\n\n    var filterableFields = [\"packages\"];\n    if (filterableFields) {\n        for (var i in filterableFields) {\n            var name = filterableFields [i];\n\n            if (typeof options [name] != 'undefined') {\n                filter = name;\n                where = options [name];\n            }\n        }\n    }\n  \n    if (where == 'null') {\n      where = null;\n    }\n  \n    range = [\n        [enabled, filter, where, sort],\n        [enabled, filter, where, sort, '\\ufff0']\n    ];\n\n    if (descending) {\n        resolved.startkey = range [1];\n        resolved.endkey = range [0];\n    } else {\n        resolved.startkey = range [0];\n        resolved.endkey = range [1];\n    }\n  \n    for (var i in [\"function (urn, resolved) {\\n    if (resolved.final) return;\\n    \\n    var options = urn.search (true);\\n    \\n    if (typeof options ['sync-sources'] != 'undefined') {\\n      delete resolved.startkey;\\n      delete resolved.endkey;\\n      delete resolved.descending;\\n      delete resolved.limit;\\n      delete resolved.key;\\n      \\n      resolved.view = 'sync-sources';\\n      resolved.final = true;\\n      resolved.autoreduce = false;\\n      resolved.reduce = true;\\n      resolved.group = true;\\n      resolved.include_docs = false;\\n    }\\n  }\"]) {\n      eval ('(' + [\"function (urn, resolved) {\\n    if (resolved.final) return;\\n    \\n    var options = urn.search (true);\\n    \\n    if (typeof options ['sync-sources'] != 'undefined') {\\n      delete resolved.startkey;\\n      delete resolved.endkey;\\n      delete resolved.descending;\\n      delete resolved.limit;\\n      delete resolved.key;\\n      \\n      resolved.view = 'sync-sources';\\n      resolved.final = true;\\n      resolved.autoreduce = false;\\n      resolved.reduce = true;\\n      resolved.group = true;\\n      resolved.include_docs = false;\\n    }\\n  }\"] [i] + ')') (urn, resolved);\n    }\n    \n\n    return resolved;\n  }",
		"validate_doc_update": "function (newDoc, oldDoc, userCtx) {\n    // Throw an error message\n    var messages = {\"overwrite-type\":\"Document type can't be changed\",\"overwrite-created_at\":\"Document creation time is fixed\",\"overwrite-created_by\":\"Document author is fixed\",\"not-allowed\":\"You are not allowed to \"};\n    var report = function (key, arg) {\n      throw ({\n        forbidden: (messages [key] || key) + (arg || '')\n      });\n    };\n    \n    if (oldDoc && oldDoc.type && oldDoc.type != newDoc.type) {\n      report ('overwrite-type');\n    }\n    \n    var username = userCtx.name || 'nobody',\n        account = 'urn:accounts/' + username,\n        roles = userCtx.roles,\n        permissions = {\"remove\":{},\"edit\":{}},\n        changes = [];\n    \n    for (var i = 0; i < roles.length; i++) {\n      if (roles [i].match (/^urn:accounts\\//)) {\n        account = roles [i];\n        break;\n      }\n    }\n    \n    \n    if (newDoc.type == 'urn:types/application') {\n      if (roles.indexOf ('_admin') == -1) {\n        throw ({\n          forbidden: \"Only database administrator can update applications\"\n        });\n      }\n    }\n    \n    // Check this app type only\n    if (newDoc.type != \"urn:types/futurios-package\") return;\n    \n    // Prevent some errors\n    var isNew = !oldDoc;\n    if (!newDoc.meta) newDoc.meta = {};\n    if (!oldDoc) oldDoc = {};\n    if (!oldDoc.meta) oldDoc.meta = {};\n    \n    // Comparator for \"changes\"\n    var eq = function (left, right) {\n      if (left == right) return true;\n      if (!left || !right) return false;\n      return left.toString () == right.toString ();\n    };\n    \n    // Check, if field was changed\n    var changed = function (key) {\n      return changes.indexOf ('change:' + key) != -1;\n    };\n    \n    // Collect all changes in root fields\n    for (var field in newDoc) {\n      if (!eq (newDoc [field], oldDoc [field])) {\n        changes.push ('change:' + field);\n      }\n    }\n    \n\t// Collect all changes in meta fields\n    for (var field in newDoc.meta) {\n      if (!eq (newDoc.meta [field], oldDoc.meta [field])) {\n        changes.push ('change:meta:' + field);\n      }\n    }\n\n    \n    // Important common checks\n    if (!isNew) {\n      if (changed ('meta:created_at')) report ('overwrite-created_at');\n      if (changed ('meta:created_by')) report ('overwrite-created_by');\n    }\n    \n    var debug = function () {\n      throw ({\n        forbidden: JSON.stringify (arguments)\n      });\n    };\n    \n    var isOwner = [newDoc._id, newDoc.meta.created_by].indexOf (account) !== -1,\n        isAdmin = roles.indexOf ('_admin') != -1;\n\n    \n    // TODO: Dirty hack, refactor\n    if (!isOwner) {\n      var lo = newDoc.meta.last_updated_origin || newDoc.meta.origin;\n      if (lo == account) {\n        isOwner = true;\n      }\n    }\n    \n    \n    var isShared = (function (shared, account, roles) {\n      if (typeof shared == 'undefined') {\n        return false;\n      }\n      \n      if (shared.indexOf (account) != -1) {\n        return true;\n      }\n      \n      for (var i = 0, tmp; i < roles.length; i++) {\n        if (shared.indexOf ('roles/' + roles [i]) != -1) return true;\n        \n        if (tmp = roles [i].match (/^companies\\/([^\\/]+)/)) {\n          if (shared.indexOf ('urn:onstra:company/' + tmp [1]) != -1) {\n            return true;\n          }\n        }\n      }\n      \n      return false;\n    }) (newDoc.meta.shared, account, roles);\n    \n    // Check, if user has permissions to do something\n    var need = function (key) {\n      if (isAdmin) return;\n      \n      var rule = permissions [key];\n      \n      if (!rule) {\n        return;\n      }\n      \n      // Check username\n      if (rule.names) {\n        if (rule.names.indexOf (username) != -1) {\n          return;\n        }\n        \n        if (rule.names.indexOf (account) != -1) {\n          return;\n        }\n        \n        if (rule.names.indexOf ('#owner') != -1) {\n          if (isOwner) return;\n        }\n        \n        if (rule.names.indexOf ('#shared') != -1) {\n          if (isShared) return;\n        }\n      } else {\n        if (isOwner) return;\n      }\n      \n      // Check role\n      var groups = rule.roles || rule.groups;\n      if (groups) {\n        for (var i = 0; i < roles.length; i++) {\n          if (groups.indexOf (roles [i]) != -1) {\n            return;\n          }\n        }\n      }\n      \n      report ('not-allowed', key);\n    };\n    \n    if (changes.indexOf ('change:_deleted') != -1) {\n      need ('remove');\n    } else {\n      need (isNew ? 'create' : 'edit');\n    }\n    \n    // Check each field for permissions\n    for (var i = 0, l = changes.length; i < l; i++) {\n      need (changes [i]);\n    }\n  }",
		"updates": {
			"urn:types/futurios-package": "function (doc, req) {\n    var ts = (new Date).getTime (),\n      username = req.userCtx.name || 'nobody',\n      roles = req.userCtx.roles,\n      design = req.path [2],\n      app = \"urn:applications/futurios-packages\",\n      type = req.path [4],\n      newDoc = JSON.parse (req.body),\n      response;\n\n    username = 'urn:accounts/' + username;\n    for (var i = 0; i < roles.length; i++) {\n      if (roles [i].match (/^urn:accounts\\//)) {\n        username = roles [i];\n        break;\n      }\n    }\n\n    if (!doc) {\n      doc = newDoc;\n\n      if (!doc.meta) {\n        doc.meta = {};\n      }\n\n      if (username == 'daemon' && doc.meta.created_by) {\n        // TODO: Replace with real user\n      } else {\n        doc.meta.created_by = username;\n      }\n      \n      doc.meta.created_at = ts;\n      doc.meta.origin = req.info.db_name;\n      doc.meta ['origin_host'] = \"temp-host\";\n\n      if (!doc._id) {\n        if (doc.id) {\n          doc._id = design + '/' + doc.id;\n          delete doc.id;\n        } else {\n          doc._id = design + '/' + req.uuid;\n        }\n      } else {\n        if (doc._id.substring (0, design.length) != design) {\n          doc._id = design + '/' + doc._id;\n        }\n      }\n    } else {\n      doc = newDoc;\n\n      if (!doc.meta) {\n        doc.meta = {};\n      }\n    }\n\n    doc.meta.updated_by = username;\n    doc.meta.updated_at = ts;\n    doc.meta.last_updated_origin = req.info.db_name;\n    doc.meta ['last_updated_origin_host'] = \"temp-host\";\n    \n    if (req.query.sessid) {\n      doc.meta.sessid = req.query.sessid;\n    }\n  \n    if (typeof doc.meta.sort_index == 'undefined') {\n      doc.meta.sort_index = ts;\n    }\n\n    if (!doc.meta.private) {\n      if (!doc.meta.shared) {\n        doc.meta.shared = [];\n      }\n\n      if (false && doc.meta.shared.indexOf (app) == -1) {\n        doc.meta.shared.push (app);\n      }\n    }\n\n    if (\"\") {\n      try {\n        var update = eval ('(' + \"\" + ')');\n        doc = update (doc, req);\n      } catch (e) {\n        doc.error = {\n          where: \"update function\",\n          message: e.toString ()\n        };\n      }\n    }\n\n    doc.type = type;\n\n    response = {\n      ok: true,\n      id: doc._id,\n      doc: doc\n    };\n\n    return [doc, {\n      headers: {\n        'Content-Type': 'application/json; charset=utf-8'\n      },\n      body: JSON.stringify (response)\n    }];\n  }"
		}
	},
	"title": "Пакеты"
}